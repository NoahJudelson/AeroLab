function [x, y, x_c, y_c] = airfoilgen(m_0, p_0, t_0, N)

m_use = m_0 / 100; % create useful mpt values for computations
p_use = p_0 / 10;
t_use = t_0 / 100;

c = 1; % normalized chord length

x = linspace(0, c, 1000); % values along chord spaced out
x_c = x; % values for camber line

y_t = 5*t_use * (0.2969*sqrt(x./c) - 0.1260*(x./c) - 0.3516*(x./c).^2 ...
    + 0.2843*(x./c).^3 - 0.1036*(x./c).^4 ); % thickness distribution equation

y_c = zeros(size(x)); % preallocate for the for loop
dyc_dx = zeros(size(x));

for i = 1:length(x) % iterates through piecewise function, also calculates xi values 
    if x(i) < p_use*c
        y_c(i) = m_use/(p_use^2) * (2*p_use*(x(i)/c) - (x(i)/c)^2);
        dyc_dx(i) = (2*m_use/(p_use^2)) * (p_use/c - x(i)/c^2);
    else
        y_c(i) = m_use/((1-p_use)^2) * ( (1 - 2*p_use) + 2*p_use*(x(i)/c) - (x(i)/c).^2 );
        dyc_dx(i) = (2*m_use/((1-p_use)^2)) * (p_use/c - x(i)/c^2);
    end

end

xi = atan(dyc_dx);

x_u = x - (y_t .* sin(xi)); % upper and lower surface x and y values
x_l = x + (y_t .* sin(xi));
y_u = y_c + (y_t .* cos(xi));
y_l = y_c - (y_t .* cos(xi));

x = [flip(x_l), x_u(2:end)]; % concatenate vector to make it a full airfoil shape in x and y
y = [flip(y_l), y_u(2:end)]; % need to flip the lower x and y vectors to move in clockwise position around airfoil

end
